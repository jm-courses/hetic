<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>CSS - Responsive Web Design</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/dracula.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs2015.css">
	<link rel="stylesheet" href="custom-styles.css">

	<style>
		.slides section .ib {
			display: inline-block;
			width: auto;
			overflow: hidden;
		}
		.slides section .ib.vt { vertical-align: top; }
		.slides section .ib.vm { vertical-align: middle; }
		.slides section .ib.vb { vertical-align: bottom; }

		.slides section .ib > code { overflow: hidden; }
	</style>
</head>

<body>

	<div class="reveal">
		<div class="slides">

			<section>
				<section>
					<h1 style="line-height: 0.7;">
						<small>Intro au</small>
						Responsive
					</h1>
				</section>
				<section>
					<p>Le <b>responsive webdesign</b> est un sous-ensemble du concept d'<b>adaptative webdesign</b></p>
					<aside class="notes">
						<p>Lorsque l’on parle de Responsive Webdesign, on fait uniquement référence à la <b>mise en page</b>.</p>
						<p>Le Design Adaptatif signifie la même chose qu’Amélioration Progressive, à savoir, <b>apporter la meilleur expérience utilisateur à la plus large audience possible</b> (audience -> différents appareils et situations de navigation). </p>
						<p>Design Adaptatif != Mise en page adaptative !</p>
					</aside>
				</section>

				<section>
					<h3>Responsive</h3>
					<p><b>Mise en page</b> : images flexibles, grilles fluides, media queries</p>
					<br>
					<h3>Adaptative</h3>
					<p><b>UX design</b> : apporter la meilleure expérience utilisateur à la plus large audience possible</p>
				</section>

				<section>
					<figure>
						<img src="images/responsive/adaptatif.jpg" alt="">
					</figure>
				</section>

				<section>
					<h3>Amélioration progressive / Progressive enhancement</h3>
					<ul>
						<li>Concept d'accessibilité et de sémantique</li>
						<li>Séparer le fond de la forme</li>
						<li>Proposer au fur et à mesure un enrichissement de la mise en forme, en fonction des capacités des périphériques d'affichage</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3 data-id="progressive-enhancement">Compatibilité minimale</h3>
					<p>Se mettre dans la pire situation</p>
					<p>Penser à la majorité des cas</p>
					<p>Device utilisé, rendu navigateur, support CSS/JS, accessibilité, rapidité réseau, etc.</p>
				</section>

				<section data-auto-animate>
					<h3 data-id="progressive-enhancement">Enrichi ensuite</h3>
					<p>Chargement asynchrone (JS, images, contenus, etc.)</p>
					<p>Stratégie offline, cache</p>
					<p>Effets visuels avancés / animations</p>
				</section>

				<section>
					<figure><img src="images/responsive/responsive-iceberg.jpg" alt="" width="512"></figure>
				</section>
			</section>

			<section id="media-queries">
				<section>
					<h2>Media-Queries</h2>
				</section>

				<section>
					<p>
						Les médias queries sont des <em>instructions conditionnelles</em> qui permettent d'appliquer des styles CSS <strong>en fonction de la largeur de l'écran ou de la résolution du périphérique de sortie</strong>
					</p>
				</section>

				<section>
					<h3>Syntaxe</h3>
					<p>Une requête média se compose d'un <strong>type de média</strong> optionnel et d'une ou plusieurs expressions de <strong>caractéristiques de média</strong></p>
					<p class="fragment">Plusieurs requêtes peuvent être combinées entre elles grâce à des <strong>opérateurs logiques</strong></p>
				</section>

				<section>
					<h3>Types de medias</h3>
					<p>Un type de média définit une catégorie générale d'appareil</p>
					<p>Il en existe 4 :</p>
					<ul>
						<li class="fragment"><code>screen</code> : appareils dotés d'un écran</li>
						<li class="fragment"><code>print</code> : documents en aperçu avant impression</li>
						<li class="fragment"><code>speech</code> : outils de synthèse vocale</li>
						<li class="fragment"><code>all</code> : tous les appareils</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Caractéristiques de média</h3>
					<p>Elles décrivent certaines caractéristiques spécifiques de l'agent utilisateur, de l'appareil d'affichage ou de l'environnement</p>
					<p>En voici quelques-unes couramment utilisées :</p>
				</section>
				<section data-auto-animate>
					<p>En voici quelques-unes couramment utilisées :<br><br></p>
					<ul style="font-size: 0.8em;">
						<li class="fragment" data-fragment-index="1"><code>min-width</code> / <code>max-width</code>: Largeur de la viewport<em>*</em></li>
						<li class="fragment"><code>min-height</code> / <code>max-height</code>: Hauteur de la viewport<em>*</em></li>
						<li class="fragment"><code>aspect-ratio</code>: Rapport largeur/hauteur de la viewport<em>*</em></li>
						<li class="fragment"><code>orientation</code>: Orientation la viewport<em>*</em></li>
						<li class="fragment"><code>resolution</code>:	Densité de pixel pour l'appareil d'affichage</li>
						<li class="fragment"><code>prefers-color-scheme</code>: Préférence de theme de l'utilisateur</li>
					</ul>
					<p class="fragment" data-fragment-index="1"><small><em>* zone d'affichage</em></small></p>
				</section>
				<section data-auto-animate>
					<p>Depuis récemment, on peut simplifier <code>min-width</code> et <code>min-height</code> :</p>
					<ul style="font-size: 0.8em;">
						<li><code>width</code>: Largeur de la viewport<em>*</em></li>
						<li><code>height</code>: Hauteur de la viewport<em>*</em></li>
						<li><code>aspect-ratio</code>: Rapport largeur/hauteur de la viewport<em>*</em></li>
						<li><code>orientation</code>: Orientation la viewport<em>*</em></li>
						<li><code>resolution</code>:	Densité de pixel pour l'appareil d'affichage</li>
						<li><code>prefers-color-scheme</code>: Préférence de theme de l'utilisateur</li>
					</ul>
					<p><small><em>* zone d'affichage</em></small></p>
				</section>

				<!-- @TODO -->

				<section data-auto-animate>
					<h3>Exemple de disposition</h3>
					<p>Un menu en <em>flexbox</em> qui va changer de direction</p>
					<pre data-id="media-query"><code class="css" data-trim contenteditable spellcheck="false" data-line-numbers="6-10">
						nav {
							display: flex;
							flex-direction: row;
						}

						@media screen and (max-width: 480px) {
							nav {
								flex-direction: column;
							}
						}
					</code></pre>
				</section>
				<section data-auto-animate>
					<h3>Exemple de disposition</h3>
					<p>Un menu en <em>flexbox</em> qui va changer de direction</p>
					<pre data-id="media-query"><code class="css" data-trim contenteditable spellcheck="false" data-line-numbers="6-10">
						nav {
							display: flex;
							flex-direction: row;
						}

						@media (width <= 480px) {
							nav {
								flex-direction: column;
							}
						}
					</code></pre>
				</section>

				<section>
					<h3>Exemple d'orientation</h3>
					<p>Une navbar qui sera positionnée en <em>sticky</em> en fonction de l'orientation</p>
					<pre><code class="css" data-trim contenteditable spellcheck="false" data-line-numbers="6-11">
						nav {
							display: flex;
							justify-content: : space-evenly;
						}

						@media (orientation: portrait) {
							nav {
								position: sticky;
								top: 0;
							}
						}
					</code></pre>
				</section>

				<section>
					<h3>Exemple de thème</h3>
					<p>Un site qui sera affiché en <em>darkmode</em> suivant la préférence de l'utilisateur sur son système (Windows / macOS / Linux)</p>
					<pre><code class="css" data-trim contenteditable spellcheck="false" data-line-numbers="6-11">
						body {
							background-color: white;
							color: black;
						}

						@media (prefers-color-scheme: dark) {
							body {
								background-color: black;
								color: white;
							}
						}
					</code></pre>
				</section>

				<section>
					<p>Il existe de nombreuses combinaisons de règles Media queries, en utilisant les opérateurs logiques</p>

					<pre><code class="css" data-trim contenteditable spellcheck="false">
						@media screen and (max-width: 650px) {}

						@media (min-width: 700px) and (orientation: landscape) {}

						@media print and (aspect-ratio: 16/9) {}
					</code></pre>
				</section>

				<section>
					<p>La page de la documentation MDN à ce sujet est très complète :</p>
					<p><a href="https://developer.mozilla.org/fr/docs/Web/CSS/CSS_media_queries/Using_media_queries" target="_blank">Utiliser les Media queries</a></p>
				</section>

				<section>
					<p>Connaître les caractéristiques de la plupart des devices mobiles :</p>
					<p><a href="https://screensiz.es/" target="_blank" rel="noopener noreferrer">screensiz.es</a></p>
					<p><small>Un outil intéressant à garder dans ses favoris</small></p>
				</section>
			</section>

			<section>
				<section>
					<h2>Optimiser les images</h2>
				</section>

				<section>
					<p>Des images optimisées sont essentielles pour une bonne expérience utilisateur, pour des raisons de <strong>performance</strong>, mais aussi de <strong>confort visuel</strong></p>
				</section>

				<section>
					<p>Pour optimiser le poids, des outils existent comme <a href="https://compressor.io" target="_blank" rel="noopener noreferrer">compressor.io</a></p>
					<p class="fragment">Mais au dela de l'optimisation, quelle utilité par exemple pour une image de fond d'avoir une résolution de 3000x1500 alors que la fenêtre du navigateur Web ne fait que 1200px de large ?</p>
				</section>

				<section>
					<p>De plus, des pages HTML peuvent demander à charger de nombreuses images, dont la plupart ne seront pas visibles immédiatement par l'utilisateur (qui ne voit que le haut de la page lors du chargement)</p>
				</section>

				<section>
					<p>Sans compter la complexité de gestion de la qualité en fonction des différents écrans et densités de pixels (Rétina, OLED, …) sur tous les devices (ordinateurs, tablettes, smartphones, …)</p>
				</section>

				<section>
					<p>Aujourd'hui, HTML propose des solutions natives et faciles à mettre-en-place pour gérer ces problématiques</p>
				</section>

				<section>
					<h3>Lazy loading</h3>
					<pre><code class="html" data-trim contenteditable spellcheck="false">
						<img src="image.jpg" loading="lazy">
					</code></pre>
					<p>Cet attribut indique au navigateur de ne pas charger l'image tant qu'elle n'est pas visible dans la viewport</p>
				</section>

				<section>
					<h3><code>srcset</code></h3>
					<p>Cet attribut  va permettre de définir une image adaptée au terminal de consultation en ciblant à la fois la <strong>taille de l'écran et la densité de pixels</strong></p>
					<p class="fragment">Il utilise des <em>descripteurs de source</em> :</p>
					<ul>
						<li class="fragment"><code>w</code> : descripteur de largeur</li>
						<li class="fragment"><code>x</code> : descripteur de densité de pixels</li>
					</ul>
				</section>

				<section data-auto-animate>
					<p>Admettons que nous disposons d'une même image en 2 tailles différentes : 300px et 600px</p>
					<pre data-id="snippet-srcset"><code class="html" data-trim contenteditable spellcheck="false">
						<img srcset="image-300.jpg 300w, image-600.jpg 600w">
					</code></pre>
				</section>

				<section data-auto-animate>
					<pre data-id="snippet-srcset"><code class="html" data-trim contenteditable spellcheck="false">
						<img srcset="image-300.jpg 300w, image-600.jpg 600w">
					</code></pre>
					<p>Ici, on indique explicitement au navigateur que l'on dispose de deux images (300px et 600px grâce au descripteur <code>w</code>) et que l'on souhaite qu'il choisisse la plus adaptée en fonction de la taille de la viewport (qu'il connaît)</p>
					<p class="fragment"><strong>C'est ensuite au navigateur de faire le choix de la meilleure image à charger</strong></p>
				</section>

				<section>
					<h3><code>sizes</code></h3>
					<p>Cet attribut <strong>vient en complément de <code>srcset</code></strong>, est n'est valable que si on a choisi le descripteur <code>w</code></p>
					<p class="fragment">Il permet d'indiquer au navigateur différentes tailles de viewport pour lesquelles on dispose d'une image adaptée</p>
				</section>

				<section data-auto-animate>
					<pre data-id="snippet-sizes"><code class="html" data-trim contenteditable spellcheck="false">
						&lt;img srcset="/image-300.jpg 300w, /image-600.jpg 600w"
								 sizes="(max-width: 400px) 200px, (max-width: 800px) 100vw, 50vw"&gt;
					</code></pre>
					<p class="fragment" data-id="sizes-desc">Dans cet exemple, le navigateur est informé que :</p>

					<blockquote style="font-size: 0.8em" class="fragment">Pour une taille de viewport inférieure ou égale à 400px, l'image devra s'afficher en 200px de large. Il prendra donc la valeur la plus proche, à savoir : image-300.jpg. Cependant, si la densité de pixels vaut 3 (= écrans super Rétina), alors il multipliera les 200px attendus par 3, et prendra donc l'image de 600px de large pour une meilleure qualité d'affichage.</blockquote>
				</section>

				<section data-auto-animate>
					<pre data-id="snippet-sizes"><code class="html" data-trim contenteditable spellcheck="false" data-noescape>
						&lt;img srcset="/image-300.jpg 300w, /image-600.jpg 600w"
								 sizes="(max-width: 400px) 200px, (max-width: 800px) 100vw, 50vw"&gt;
					</code></pre>
					<p data-id="sizes-desc">Dans cet exemple, le navigateur est informé que :</p>
					<blockquote style="font-size: 0.8em">Pour une taille de viewport inférieure ou égale à 800px, l'image devra s'afficher à 100% de la largeur de la viewport (c'est-à-dire 800px). Il choisira donc systématiquement image-600.jpg.</blockquote>
				</section>

				<section data-auto-animate>
					<pre data-id="snippet-sizes"><code class="html" data-trim contenteditable spellcheck="false">
						&lt;img srcset="/image-300.jpg 300w, /image-600.jpg 600w"
								 sizes="(max-width: 400px) 200px, (max-width: 800px) 100vw, 50vw"&gt;
					</code></pre>
					<p data-id="sizes-desc">Dans cet exemple, le navigateur est informé que :</p>
					<blockquote style="font-size: 0.8em">Si aucune des conditions précédentes n'est remplie, l'image devra s'afficher à 50% de la largeur de la viewport. C'est-à-dire que si on dispose d'une viewport faisant 820px, l'image s'affichera à 410px de large (= 50% de la viewport). Le navigateur choisira donc l'image de 300px de large car c'est la valeur la plus proche de 410px (pour un écran de 1x).</blockquote>
				</section>

				<section>
					<p>Il est important de comprendre que toutes ces possibilités ont pour but de donner un maximum d'information au navigateur pour qu'il puisse charger les images de la meilleure façon possible</p>

					<p class="fragment">Mais le navigateur est libre de choisir la méthode qu'il souhaite et vous ne serez pas forcément sûr de voir les images charger de la manière que vous avez définie</p>
				</section>

				<section>
					<p>L'article suivant reprend en détails les notions vues dans ce chapitre :<br>
					<a href="https://www.builder.io/blog/fast-images#async-image-decoding" target="_blank" rel="noopener noreferrer">Optimal Images in HTML.</a></p>
				</section>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom]
		});

		Reveal.configure({
			pdfSeparateFragments: false,
		})
	</script>
</body>

</html>